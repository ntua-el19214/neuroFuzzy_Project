function x_dot = nonLinearVehicleModel(t, Y, vehicle, delta, ssVectorSA, ExpandedMatrices)
% NONLINEARVEHICLEMODEL describes the non-linear equations that dictate vehicle dynamics

% Initialize integral term for yaw control
persistent integral_yaw_error accel b_dot
if isempty(integral_yaw_error)
    integral_yaw_error = 0;
end

g = 9.81; % Gravitational acceleration

% Extract state variables
psi_dot  = Y(1);  % Yaw rate
v        = Y(2);  % Longitudinal velocity
b        = Y(3);  % Side-slip angle
omega_FL = Y(6);  % Wheel angular velocity (front left)
omega_FR = Y(7);  % Wheel angular velocity (front right)
omega_RL = Y(8);  % Wheel angular velocity (rear left)
omega_RR = Y(9);  % Wheel angular velocity (rear right)

% Kinematic calculations
vx = v * cos(b);
vy = v * sin(b);

% Acceleration calculations
ay = v * b_dot + psi_dot * v;
ax = sign(accel^2 - ay^2) * sqrt(abs(accel^2 - ay^2));

% Vehicle geometry and load distribution
lf = vehicle.wb * (1 - vehicle.wd);
lr = vehicle.wb * vehicle.wd;
bf = vehicle.tf;
br = vehicle.tr;

% Calculate normal forces (Fz)
Fz_fl = vehicle.m * g * vehicle.wd / 2 + (vehicle.CoGz * vehicle.m * ay / (2 * vehicle.tf)) - ...
        (vehicle.CoGz * vehicle.m * ax / (2 * vehicle.wb)) + 1/2 * 1/4 * 1.22 * 5.7 * vx^2;
Fz_fr = vehicle.m * g * vehicle.wd / 2 - (vehicle.CoGz * vehicle.m * ay / (2 * vehicle.tf)) - ...
        (vehicle.CoGz * vehicle.m * ax / (2 * vehicle.wb)) + 1/2 * 1/4 * 1.22 * 5.7 * vx^2;
Fz_rl = vehicle.m * g * (1 - vehicle.wd) / 2 + (vehicle.CoGz * vehicle.m * ay / (2 * vehicle.tr)) + ...
        (vehicle.CoGz * vehicle.m * ax / (2 * vehicle.wb)) + 1/2 * 1/4 * 1.22 * 5.7 * vx^2;
Fz_rr = vehicle.m * g * (1 - vehicle.wd) / 2 - (vehicle.CoGz * vehicle.m * ay / (2 * vehicle.tr)) + ...
        (vehicle.CoGz * vehicle.m * ax / (2 * vehicle.wb)) + 1/2 * 1/4 * 1.22 * 5.7 * vx^2;

% Calculate slip ratios and slip angles
speedFL = (vx - psi_dot * br / 2 * cos(delta) + (vy + psi_dot * lf) * sin(delta));
speedFR = (vx + psi_dot * br / 2 * cos(delta) + (vy + psi_dot * lf) * sin(delta));
speedRL = (vx - psi_dot * br / 2);
speedRR = (vx + psi_dot * bf / 2);

slip_FL = calculateSlipRatio(omega_FL, speedFL, vehicle.R);
slip_FR = calculateSlipRatio(omega_FR, speedFR, vehicle.R);
slip_RL = calculateSlipRatio(omega_RL, speedRL, vehicle.R);
slip_RR = calculateSlipRatio(omega_RR, speedRR, vehicle.R);

slipAngle_FR = atan((vy + lf * psi_dot) / (vx + bf / 2 * psi_dot)) - delta;
slipAngle_FL = atan((vy + lf * psi_dot) / (vx - bf / 2 * psi_dot)) - delta;
slipAngle_RR = atan((vy - lr * psi_dot) / (vx + br / 2 * psi_dot));
slipAngle_RL = atan((vy - lr * psi_dot) / (vx - br / 2 * psi_dot));

% Calculate tire forces
Fx_fl = F_longit(slipAngle_FR, slip_FR, Fz_fl, deg2rad(-0.5));
Fx_fr = F_longit(slipAngle_FL, slip_FL, Fz_fr, deg2rad(-0.5));
Fx_rl = F_longit(slipAngle_RR, slip_RR, Fz_rl, deg2rad(-0.5));
Fx_rr = F_longit(slipAngle_RL, slip_RL, Fz_rr, deg2rad(-0.5));

Fy_fl = F_lateral(slipAngle_FR, slip_FR, Fz_fl, deg2rad(-0.5));
Fy_fr = F_lateral(slipAngle_FL, slip_FL, Fz_fr, deg2rad(-0.5));
Fy_rl = F_lateral(slipAngle_RR, slip_RR, Fz_rl, deg2rad(-0.5));
Fy_rr = F_lateral(slipAngle_RL, slip_RL, Fz_rr, deg2rad(-0.5));

% Update the acceleration and beta_dot in the state
v_dot = 1 / vehicle.m * ((Fx_fl + Fx_fr) * cos(delta - b) - (Fy_fl + Fy_fr) * sin(delta - b) + ...
                        (Fx_rl + Fx_rr) * cos(b) + (Fy_rl + Fy_rr) * sin(b) - ...
                        1/2 * 1.224 * vehicle.cd * v^2 * cos(b));

beta_dot = (1 / (vehicle.m * v)) * ((Fx_fl + Fx_fr) * sin(delta - b) - (Fy_fl + Fy_fr) * cos(delta - b) + ...
                                (Fx_rl + Fx_rr) * sin(b) + (Fy_rl + Fy_rr) * cos(b) + ...
                                1/2 * 1.224 * vehicle.cd * v^2 * sin(b)) - psi_dot;

% Ïˆ_ddot (yaw acceleration)
psi_ddot = (1 / vehicle.Jz) * (lf * ((Fx_fl + Fx_fr) * sin(delta) + (Fy_fl + Fy_fr) * cos(delta)) - ...
                               lr * (Fy_rl + Fy_rr) + bf / 2 * (-Fx_fl + Fx_fr) * cos(delta) - ...
                               (-Fy_fl + Fy_fr) * sin(delta) + br / 2 * (Fx_rr - Fx_rl));

% Update these states directly (not integrated)
acceleration = v_dot;  % Update the current acceleration value
lateral_slip_rate = beta_dot;  % Update the current lateral slip rate

% Ensure Y(4) and Y(5) contain these current values but aren't integrated
Y(4) = acceleration;
Y(5) = lateral_slip_rate;

% Calculate motor torque and wheel accelerations
psi_dot_desired = v * delta / (lf + lr);
yaw_error = psi_dot_desired - psi_dot;
integral_yaw_error = integral_yaw_error + yaw_error * t;

gainStruct = gainScheduling(delta, ssVectorSA, ExpandedMatrices);
input = yaw_error * gainStruct.Kp + integral_yaw_error * gainStruct.Ki - gainStruct.Kr * [b; psi_dot];
slipAngleMatrix = [slipAngle_FL, slipAngle_FR, slipAngle_RL, slipAngle_RR];
fzMatrix = [Fz_fl, Fz_fr, Fz_rl, Fz_rr];
omegaMatrix = [omega_FL, omega_FR, omega_RL, omega_RR];

Tmotor = motorTorque(vehicle, input, slipAngleMatrix, fzMatrix, omegaMatrix);

omega_FL_dot = (Tmotor(1) - Fx_fl * vehicle.R) / vehicle.Jw;
omega_FR_dot = (Tmotor(2) - Fx_fr * vehicle.R) / vehicle.Jw;
omega_RL_dot = (Tmotor(3) - Fx_rl * vehicle.R) / vehicle.Jw;
omega_RR_dot = (Tmotor(4) - Fx_rr * vehicle.R) / vehicle.Jw;

% Return the state derivatives
x_dot = [psi_ddot;   % Change in yaw rate
         v_dot;      % Change in velocity
         beta_dot;   % Change in slip angle
         0;          % Keep acceleration Y(4) updated, not integrated
         0;          % Keep beta_dot Y(5) updated, not integrated
         omega_FL_dot;
         omega_FR_dot;
         omega_RL_dot;
         omega_RR_dot];
end
